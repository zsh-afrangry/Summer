# 数据库核心理论与设计

之前提到的TCL，这里会有演示

# 事务

事务是一组 必须 作为一个整体进行执行的SQL操作序列，这个序列要么全部成功执行（提交），要么全部不执行（回滚）

## ACID

以”银行转账“为例，A要给B转100块钱。这个操作包含两个步骤：

1. A的账户里扣除了100块钱
2. B的账户里增加了100块钱

### 原子性 atomicity

- 解释：
    - 事务是不可分割的最小工作单元
    - 事务中的所有操作要么全部成功
    - 一旦有一个步骤出错，将会全部回滚到事务开始前的状态，就像什么都没发生一样
- 本例：
    - 如果从A账户扣除了100块钱后，系统突然崩溃
    - 原子性保证了系统恢复后，会撤销A账户扣除的100块钱（回滚），A的钱会回来
    - 绝对不能出现”A的钱扣了，B的钱没增加“的情况

### 一致性 Consistency

- 解释：
    - 事务的执行必须 使得 数据库 从 一个 `一致性状态` 到 另一个 `一致性状态`
    - 一致性 关注的是，某个事务的进行前后，数据库的`业务规则`和`约束`没有被破坏
- 本例：
    - 一致性可以指”银行存款的总金额保持不变“
    - 转之前A+B总金额是X，转之后A-100，B+100，A+B应该还是X
    - 数据库保持一致性，即事务保持所有业务规则不能发生变化

### 隔离性

- 解释：
    - 当多个事务并发执行时，一个事务的执行 不应该被 其他事务干扰
    - 一个事务内部的操作及其 使用的数据 对i其他并发事务时隔离的
    - 执行期间，各个事务之间不能相互干扰
- 本例：
    - 在A向B转账的事务（事务1）完成之前，有另一个查询（事务2）对此 进行观测
    - 它（事务2）绝对不能看到“A已扣款，B暂时未到账”这种中间 状态
    - 隔离性保证了事务2只能看到`A未向B转账`或者`A向B转账完成`这两种状态，别的都不行

### 持久性 Durability

- 解释：
    - 一旦事务被成功提交，它对数据库中数据的改变就是永久性的
    - 即使接下来系统发生崩溃，数据库也能够通过日志等方式恢复
    - 已提交的事务结果不会被丢失
- 本例：
    - A向B转账100块钱成功以后，显示事务已提交，然后这一瞬间机房断电了
    - 后来电力恢复，数据库重启
    - 持久性保证了 恢复后A给B转账这个事件是确凿存在的，数据不会因为宕机而丢失

## 事务的隔离级别

隔离性并不是绝对的”0“或”1“，而是有不同程度的

数据库定义了四种隔离级别，由低到高，隔离性越来越强，但并发性能越来越差

四种隔离级别分别是：读未提交、读提交、重复读、序列化

应对的是三类SQL问题问题：脏读、不可重复读、幻读

### 并发场景下的三类问题

- 脏读：事务T1 读到了 事务T2 未提交的更改，且事务T2回滚
    - T1读取到的是一个脏的，未在数据库中正式存在过的无效数据
- 不可重复读：事务T1在同一个事务中，`先后两次`读取`同一行`数据，得到`不同结果`
    - 因为：两次读取之间，事务T2对改行数据执行了`UPDATE`或 `DELETE`且`提交了事务`
- 幻读：事务T1在同一个事务中，`先后两次`读取`同一行`数据，两次结果集的行数发生变化
    - 因为：两次读取之间，事务T2对改行数据执行了`INSERT`且`提交了事务`

### Read uncommitted

<aside>
💡

一个事务可以读取到另一个事务**尚未提交**的修改

这是最低级的隔离级别，几乎没有任何并发控制

</aside>

可能发生的并发问题：脏读、不可重复读、幻读

### Read  committed

Oracle 和 SQL Server的默认隔离级别

<aside>
💡

解决了脏读这个最严重的问题，至少保证了不会拿到一份从未在数据库存在的“假数据”

但是无法保证，在一个读的过程中，某行数据会被人修改

</aside>

可能发生的并发问题：不可重复读、幻读

### Repeatable read

MySQL的默认隔离级别，防止了`UPDATE`和`DELETE`的并发

可以看成是，对数据库的指定范围内进行一次快照，以后不管怎么读，只要是这个范围内的数据，都按 快照 里的的数据进行返回。但是快照外可能多出来一行，这个没法解决

<aside>
💡

确保了在一个事务内，无论怎么读，同一行的数据是绝对不会变的

但是无法保证，会突然多读出一行出来

</aside>

可能发生的并发问题：幻读

### Serializable

提供了最强的数据一致性保证

它强制所有的事务，一个一个的串行执行，T1没执行好的时候，T2和T3不允许执行

<aside>
💡

这是绝对安全的并发控制，代价是牺牲了并发性，导致性能极差

</aside>

可以用于银行等 对于安全性要求极高的场合，类比银行柜台业务，前一个人没办完，后面的只能等

- 隔离级别越高，安全性越强，性能越低
- 隔离级别的选择，本质上 是在 数据一致性 与 系统并发性能 之间做取舍

# 索引

## 索引的概念

索引就是一本书的目录

思考这个情境：我想从一本厚厚的，有着1000页的《现代数据库大全》里找关于“B+树” 的章节

- 没有索引：
    - 唯一的办法就是从第一页开始，遍历整本书，直到找到为止
    - 运气最差需要1000次，复杂度为O(n)
- 有索引：
    - 我可以先翻到书最前面的目录，按照章节标题（比如字母表或者其他顺序）快速查找
    - 找到“B“开头的章节后，定位”B+树“，找到它所在页数，直接翻过去即可
    - 只有标题的查找，可以近似于O(1)

在数据库中：

- 这本《现代数据库大全》就是我的数据库表
- 书的内容 就是 表中的数据行
- 目录 就是 我创建的索引

所以，索引这种特殊的数据结构

它以一种高效的方式存储了表中`特定列的值`以及`这些值所在行的物理地址`（指针）

在数据库查询时，先查索引，快速定位到数据行，再进行查找，从而避免了全表扫描

## 索引的演示

### 单列索引

还是以员工表为例，之前我们已经设计了一个员工表：

```sql
-- 需要定义表名、列名、每一列的数据类型、约束（主键、非空等）
CREATE TABLE employees(
		id INT PRIMARY KEY, -- id，int类型，是主键，逗号隔开
		first_name VARCHAR(50) NOT NULL, -- 名，50字符以内的字符串，不可为空
		last_name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10, 2), -- 薪资，使用DECIMAL类型，数字型128bit，小数点左边10位，右边2位
    hire_date DATE -- 聘用日期，数据类型是DATE（年月日，没有时分秒）
);
```

然后模拟了数据：

| id | first_name | last_name | department | salary | hire_date |
| --- | --- | --- | --- | --- | --- |
| 1 | John | Doe | HR | 60000 | 2022-01-15 |
| 2 | Jane | Smith | Engineering | 85000 | 2021-03-22 |
| 3 | Peter | Jones | Engineering | 95000 | 2020-05-30 |
| 4 | Emily | Williams | Sales | 72000 | 2022-08-10 |
| 5 | Michael | Brown | Sales | 78000 | 2021-11-01 |
| 6 | Sarah | Davis | HR | NULL | 2023-02-20 |

<aside>
💡

注意！索引并不需要自己的”索引表“或者”目录表“！它是一个独立的特殊数据文件

数据库管理系统DBMS（MySQL）会自己去管理索引文件，我们只需要创建和使用就行

</aside>

我们执行查找语句一般是这个：

```sql
-- 找出所有销售部门的员工
SELECT * FROM employees WHERE department = 'Sales';
```

这就相当于HR拿着员工花名册，一个一个去看员工是否是销售部，效率比较低

```sql
-- 现在，我们可以给department创建一个索引：
CREATE INDEX idx_department ON employees (department);
```

- `CREATE INDEX` 是创建索引的指令
- `idx_department`是我们给索引起的名字，为了便于识别，一般是`idx_`+`列名`
- `ON employees` 指明了这个索引是建立在`employees`表上的
- `(department)`指明了这个索引是建立在`department`列上的
- 至此，一个索引创建完成，接下来是运用这个索引进行查找，查找语句与之前完全相同
- 现在，DBMS不再扫描employees表，而是先看我们创建的idx_department索引
- 这个索引文件是按department列的字母序号排列的（所有的`Engineering`在最前面）
- 这样，在索引中，能很快找到所有Sales条目，而每个条目后面都跟着原始数据行指针
- 然后DBMS就能直接定位原始数据表中目标列

### 复合索引

如果需求变更，不单单是根据department列来查找，而是频繁根据部门+名字的组合查找

比如：

```sql
SELECT * FROM employees WHERE department = 'Engineering' AND last_name = 'Smith';
```

如果只用department索引，确实能查出所有Engineering部门的人，再从里面找人

这样确实比以前快，但是依然有优化的空间：

```sql
CREATE INDEX idx_dept_lastname ON employees (department, last_name);
```

创建组合索引（先按`department` 排序，在 `department` 相同的情况下，再按 `last_name` 排序）

**这个索引可以高效地支持以下查询：**

- `WHERE department = '...'` (遵循最左前缀原则)
- `WHERE department = '...' AND last_name = '...'` (遵循最左前缀原则)

**但无法高效支持这个查询：**

- `WHERE last_name = '...'` (因为跳过了最左边的 `department`，索引失效)

### 主键索引

在创建表的语句中有一个`id INT PRIMARY KEY`

当我把id设置为`PRIMARY KEY`的时候，数据库就自动为其创建了一个唯一且非空的索引，即主键索引

所以，用主键查询索引`SELECT * FROM employees WHERE id = 101`，这是最快的！

## 索引的优缺点

优点：大大提高了查询速度`SELECT`

缺点：降低了修改数据的速度（`UPDATE，INSERT，DELETE`）

如果对数据表的内容做了修改，目录可能也需要跟着更新

（每次在word里改完报告之后，都要重新生成目录）

- INSERT：比如在书中增加了一个章节，那么必须在目录中增加新章节的标题和页码
- DELETE：在书中删掉了

## 索引的底层结构

数据库索引可以是多种数据结构实现，但是目前关系型数据库中用的最多的，是B+树

为什么要是B+树？因为其非常适合磁盘存储。这里简答介绍一下B+树的一些特点

1. 它是一棵平衡树
    1. 无论树有多高多大，从根节点到任何一个叶子节点的路径长度都几乎相同
    2. 这意味着任何一次查询的I/O次数都非常稳定，没有“运气不好，查得慢”的情况
2. 非叶子节点 只储存目录信息，不储存实际数据
    1. 目录信息即 键值 和 指针
    2. 这使得每个节点可以容纳更多的键值，从而让整棵树变得“矮胖”
    3. 树越矮，查询时磁盘的IO次数越少，速度就越快
    4. B+树本身的查询速度也达到了logN级别
3. 所有数据都存储在叶子节点上
4. 所有的叶子节点组成了一个双向链表
    1. 这是B+树的点睛之笔，所有叶子节点都串联在一起，而且是有序的
    2. 这个特性使得 范围查询 变得容易（比如`WHERE age BETWEEN 20 AND 30`）
    3. 这样数据库只需要定位到20，再沿着链表遍历到30即可

## 索引的设计原则（实战关键）

理论知识落地。如何评判一个索引的好坏？如何设计一个好的索引？

### 哪些列适合做索引

简单来说，哪些列查在找时用的多，就拿过来做索引

- 经常在`WHERE`字句中作为查询条件的列
    - `SELECT * FROM users WHERE user_id = 123;`
    - 给 `user_id` 这个列创建一个索引
- 经常在 `JOIN` 子句中作为`ON条件`，即`关联条件`的列（通常是外键）
    - `SELECT * FROM employees AS e JOIN departments AS d ON e.department = d.dept_name;`
- 经常在 `ORDER BY` 或 `GROUP BY` 子句中用于排序或分组的列
    - 索引本身是有序的，可以避免额外的ORDER的排序开销

### 最左前缀原则

这是复合索引的核心规则，非常重要，之前也有过演示

如果我对（col1，col2，col3）这三个列建立了一个复合索引，那么我的查询条件必须从左往右

否则，索引不会生效

比如我建立的复合索引是`INDEX(name, age, city)`，有以下查询

- `WHERE name = 'A' AND age = 20 AND city = 'B'` -> 三个都有，索引生效
- `WHERE name = 'A' AND age = 20` -> 有name 和 age，索引生效
- `WHERE name = 'A'` -> 有最左边的name，索引生效
- `WHERE age = 20` -> 查询是中间的age，索引不生效
- `WHERE name = 'A' AND city = 'B'` -> 查name部分，索引生效，跳过了age到city，city的索引不生效
    - 数据库利用索引的`name`部分，通过B+树快速定位到第一个`name='A'` 的数据
    - 由于索引是有序的，所以所有的`name='A'`的数据在逻辑上连续存放，DBMS沿着链表扫描，很快就能得到所有`name='A'`的数据的地址
    - DBMS拿到地址后，回到数据库读取完整数据（回表），对每个数据，检查其city值
    - `也就是说city部分的查询是遍历，不走索引`

### 索引失效场景

1. 在索引列上使用函数或计算：`WHERE YEAR(create_time) = 2025`
    1. 这时候索引是不起作用的，函数优先，索引没那么智能
    2. 正确做法是`WHERE create_time >= '2025-01-01' AND create_time < '2026-01-01'`
2. 

# 范式

通过消除冗余数据 来 优化数据库结构

范式是一种指导理论，遵循它可以 减少数据冗余、避免数据不一致、提高数据完整性

## 依赖

在JAVA里面，有依赖的说法。类A中如果有类B的实例，则称A依赖于B

数据库里的依赖，描述的是数据之间的决定关系

<aside>
💡

如果A依赖于B，那么一旦我们直到了B的值，就能唯一确定A的值，即B→A

</aside>

## 三大范式

- 第一范式：消除组合列
    - 要求：保证每一列都是不可再分的原子值
    - 例子：“地址”列 不应该存储 “省+市+县+门牌号”，而应该拆成“省份”列，“地级市”列，“县级市”列，“详细住址”列，这四列
- 第二范式：消除部分依赖
    - 要求：在满足第一范式的基础上，表中所有非主键列 必须完全依赖于主键 而非主键的一部分
        - 第二范式主要针对的是：复合主键
    - 例子：一个“订单详情”表 的 主键是`(订单ID，商品ID)`，如果表中有一个列是`订单创建时间`
        - 那么这个列 是 依赖于`订单ID`的，但是不依赖于`商品ID`，这就是部分依赖
    - 部分依赖必然造成数据冗余
        
        ![image.png](/vivo50/resources/database/database2/image.png)
        
        - 这个表中，键盘价格只依赖于`商品ID`，订单日期只依赖于`订单ID`，它们在表中重复出现
        - 正确的做法是，另外创建订单表，将`订单日期`放在”订单“表中，而非”订单详情表“
- 第三范式：消除传递依赖
    - 要求：在满足第二范式的基础上，表中的所有非主键列 都必须 直接依赖于主键，无传递依赖
    - 例子：如果employees表中包含`部门ID`和`部门名称`
        - 这时候，`部门名称`依赖于`部门ID`，`部门ID`依赖于主键`员工ID`，形成传递依赖
    - 传递依赖造成了数据的不必要存储
        
        ![image.png](/vivo50/resources/database/database2/image1.png)
        
        - `员工ID`能唯一确定`员工姓名`和`部门ID`，所以`员工姓名`与`部门ID`依赖于`员工ID`
        - `部门ID`能唯一确定`部门名称`和`部门经理`，所以`部门名称`和`部门经理`依赖于`部门ID`
        - `员工ID`唯一确定`部门ID`，`部门ID`唯一确定`部门名称`
        - 这就导致了”市场部“和”王经理“出现了两次，数据冗余
        - 如果技术部的最后一个员工李四离职（这行数据被删），就永远丢失了”D02是技术部“这个信息了
        - 正确做法是，创建一个独立的departments表，存放`部门ID`+`部门名称`+`部门经理`，员工表只存储外键`部门ID`