# 哈希密码与安全基础

# 第一课：密码存储的核心原则与经典威胁

1. 为什么不能绝对明文存储密码？
2. 如何用“哈希”来解决问题？
3. 如何用”盐”和“胡椒”来把哈希做的更安全？

## 核心概念：明文存储的危害

如果在一个网站上注册了一个账号用户名是 `user123`，密码是 `MySecretPwd!`

存到数据库的一张表里，是这样的：

| id | username | password |
| --- | --- | --- |
| 1 | admin | root |
| 2 | user123 | MySecretPwd |

这是明文存储，所有的信息都是明显可以看出来的。这相当于直接把保险箱的密码写在保险箱的门上，没有任何保险的意义。

一旦有人通过任何手段（比如SQL注入）获取了数据库的访问权限，那么他们就可以直接下载这个user表，然后：

- 所有人的账号密码 均被暴露
- 连锁反应：有的人图省事，可能在很多账号上使用相同或者类似的密码，这会引起更大范围的信息安全问题

所以，绝对不能让任何人从数据库中看出用户的原始密码（包括我们自己）

## 核心概念-哈希 vs 加密

如果不明文存储密码，就会涉及一个矛盾：

<aside>
💡

我们 看不出原始密码 的同时，需要 通过原始密码验证用户的身份

</aside>

这时候，“哈希”Hashing就登场了

- 加密：这是一个双向的过程
    - 既可以 通过密钥 把信息锁上（加密）
    - 也可以用同一把 / 或者另一把配对 的钥匙 把信息解开（解密），恢复原始内容
    - 这就相当于给日记上锁，这个锁以后是可以被打开，恢复成一个不带锁的日记的
- 哈希：这是一个单向的，不可逆的过程
    - 通过一个数学算法（Hash函数）将任意长度的数据转化为一个固定长度的字符串
    - 这是100%能够完美适用于密码存储，我们并不需要知道用户的原始密码是什么
    - 我们只要知道：用户这次输入的数据，经过Hash函数计算后得到的结果，与最开始的时候，是一样的，就行了
- 加密用于需要二次查看原始信息的场景，比如用户的银行卡号、地址信息
- 哈希用于“验证”

哈希何时工作？

1. 注册时，用户输入密码`MySecretPwd!` ，服务器计算hash(”MySecretPwd!”)，得到一个字符串
    1. 服务器只存这个hash函数执行过后得到的字符串
2. 登陆时，用户再次输入密码`MySecretPwd!`，服务器计算此次的hash函数的值
    1. 如果哈希值与存储的哈希值匹配，就证明密码正确

## 经典攻击手段

假设，我获取了一个user.db，这里有所有用户的账号和哈希处理过后的密码：

| 用户名 | 密码哈希值 |
| --- | --- |
| 李雷 | e10adc3949ba59abbe56e057f20f883e |
| 韩梅梅 | 202cb962ac59075b964b07152d234b70 |

我的目标：根据user.db中的哈希值，推导出原有的密码是什么，我有三种方法：

- 字典攻击
    - 我有一个文本文件`passwords.txt`，里面包含了数百万个最常见的密码：
        
        ```java
        123456
        password
        qwerty
        iloveyou
        admin
        ...
        ```
        
    - 然后我写了一个简单的程序，这个程序读取了字典的第一个词：123456
    - 计算它的哈希值：`md5("123456")` -> `e10adc3949ba59abbe56e057f20f883e`
    - 然后我拿着这个密码去 user.db中比对，发现匹配到了！
    - 那么，我就破解了一个人的密码：李雷 -> 123456
    - 这种方法，准备了m个密码破解n条数据的数据库表的效率大约是m*n*O(Hash)，对于计算机来说，处理起来很快
    - 但是对于不在文本文件中的 密码，就无能为力了
- 暴力手段
    - 这个方法会更加的费时费力
    - “我有的是时间 和 计算能力”，从头试到尾，总能试出来
    - 开始无尽尝试（自己生成密码后，Hash处理并进行比对）
        - 尝试长度为1的密码：1，a，#，…
        - 尝试长度为2的密码：12，ab，@a，…
        - …
    - 当其尝试到长度为6的密码：123456的时候，获取其hash值，发现匹配成功了一个
    - 这个做法需要的时间是多少？以简单字符表为例
        - 存在：数字10个，字母26个（大小写），常用特殊字符8个。共70个字符
        - 长度为”6“的密码组合有$70^6$个，想要破解一个密码，需要$70^6$次尝试
        - 这个值是1176亿4千9百万
        - 假设攻击者使用的是一个比较好的消费级显卡（GPU）来进行破解，对于像 `MD5` 或 `SHA-1` 这种计算速度极快的哈希算法，一秒可以匹配100亿次
        - 也就是说，6位强密码的匹配时间是12秒不到，非常容易被破解
- 彩虹表攻击
    - 如果觉得计算Hash值太慢了，我将开辟一块非常大的空间，将市面上所有常见的原始密码 与其 哈希值 整理成为了一本巨大无比、可快速查询的密码对照本（彩虹表）
    - 然后，我直接输入user.db中的哈希值，只要遍历一遍配对，就能找到其对应的密码
    - 这是用空间换时间的方法，提前准备相当规模的彩虹表使得匹配时间大大降低，可以几乎瞬间就能得到答案

## 经典防御手段

<aside>
💡

对于同一个哈希算法，`hash("password123")`的结果永远是相同，因此 会被 破解

</aside>

### 解决办法：加盐（Salt）

假设两个用户都使用了`123456`这样一个简单密码

- 用户A：
    1. 生成了一个随机盐：`aJk78_p!`
    2. 拼接密码：`123456`+`aJk78_p!`
    3. 哈希：`hash("123456aJk78_p!")` -> `hash_A`
- 用户B：
    1. 生成了一个随机盐：`Lp0@s3dN`
    2. 拼接密码：`123456`+`Lp0@s3dN`
    3. 哈希：`hash("123456Lp0@s3dN")` -> `hash_B` 

现在，即使原始密码相同，但是因为盐不同，所以最终存入数据库的 `hash_A` 和 `hash_B` 完全不同

分析：

1、“加盐”给每一个用户添加一个盐，攻击者没法通过 一张通用的彩虹表来破解，因为这在生成彩虹表上是无法完成的任务（对每个用户的8个随机字符，组合出$70^8$的表长度），因此ban掉了彩虹表

2、6位的密码暴力破解需要13秒，再加8位盐需要$13*70^2$即63700秒，0.7天。如果是稍微大一点的数据库（比如400行），完全破解需要1年的时间，时间成本过高

### 补充概念-胡椒

胡椒是一个全局的，放在服务器端的、秘密的字符串

它和盐的区别在于：盐是每个用户各不相同，与密码一起存在数据库里

胡椒是所有用户共用这一个

<aside>
💡

胡椒 $绝对$ 不能放在数据库里，一般是存放在 安全的配置文件 或者 环境变量中

</aside>

那么，如果加上盐 和 胡椒的密码，加密就变成了：

`hash(用户密码 + 用户的盐 + 全局的胡椒)` ，这相比于单独的用户的密码，安全性大大加强

哪怕attacker破解了我的数据库，获取了数据库内的全部信息（哈希密码 和 盐）。但是只要拿不到我的“胡椒值”，依然无法通过上面三种经典方法进行暴力破解

# 第二课：现代密码哈希算法

我们上节课的结论是，对于简单的哈希算法（比如MD5），由于同一个密码 的 哈希值是确定的，所以它存在被破解的可能；由于现代的一张普通的游戏显卡GPU有数千个核心，可以进行海量计算（我们预估的是1秒100亿次）。即”哈希确定性“与”哈希计算速度“两方面的缺陷。

我们的核心思想是：消除确定性，降低计算速度

## MD5 / SHA-1

这两个算法的计算速度极快，导致了即使密码非常复杂，只要攻击者的算力足够，破解只是时间问题

因此，MD5 / SHA-1 现在基本上不再用于密码哈希，而是用于文件验证：从网上下载文件的时候，网站一般会给一个MD5的值来确认文件在传输过程中是否有损坏

## 现代密码策略

通过人为地增加 “单个密码验证 的 成本”，来指数级增加 “attacker进行大规模破解的总成本”

在计算机科学的绝大多数领域，快、效率高 是我们追求的目标，但是在密码哈希领域，“快”是一种漏洞，“慢”才是一种安全性。毕竟，你快了，攻击者破解也快了

## 三种现在加密方法

### bcrypt

bcrypt是第一个被广泛接受的”慢“算法，顺带一提，Spring Security用的就是这个

<aside>
💡

它是一个CPU密集型算法，内置“成本因子”。设置成本因子的值，造成大量迭代延长时间

比如把因子 从10变成11，可将哈希算法的时间成本从1024变为2048，从而 实现 数级放大

</aside>

比如说，在登录功能中，我在登录验证（哈希计算并匹配）的过程中内置一个$2^n$的循环算法，这个算法的目的就是让整个验证过程的时间变长

根据摩尔定律，计算机硬件每18-24个月 会 迭代增长一倍，而我只要将循环的成本因子n从10变成11，即可将2^10=1024变为2^11=2048，使得验证的时间大致延长一倍

即使attacker使用的是再高算力的GPU，也不得不在哈希破解时运行2048次我的循环算法，从而使得破解时间变慢

补充一点：Bcrypt 的慢是基于 "Blowfish" 这个加密算法 的 密钥扩展（key setup）部分，它本身就是为慢速而设计的。

### scrypt

<aside>
💡

这是一个内存密集型算法，通过大量内存消耗，提高破解的成本

</aside>

还是登录验证这个模块的应用，我在登录验证（哈希计算并匹配）的过程中内置一个申请内存的代码，使得每次验证时，都需要申请一块2GB的内存空间，验证成功后立刻释放

对于我来说，一次消耗2GB的空间并不算大，现在一般的应用级服务器肯定都不止2GB内存

但是对于attacker来说，如果他的超级GPU有16000个核心，如果想要全力破解我的user.db这张表，需要16000*2GB的内存空间，这是完全不可能的，成本比我的user.db高多了

如果attacker的超级GPU有96GB，也不过能同时进行48个计算，16000核心大部分都被闲置了

### Argon2

它不仅集成了bcrypt的时间成本、scrypt的空间成本，还引入了并行数量

便于计算，我将我的服务器设置为160核，也就是attacker的GPU的1 / 100

看一下哈希过程需求：

- 成本因子n = 11，内存申请m = 64MB，并行线程p = 4

看一下我的配置：160核，内存16GB

- **服务器端：**总内存消耗 `64MB * 4 = 256MB`，调整迭代次数 `t` 使得 让验证在 200ms 左右完成
    - 这对于服务器是完全可行的。
    - 4 个并线线程之间，需要频繁同步数据，相互通信

看一下attacker的高级配置：16000核，顶级内存96GB

- **攻击者端 (96GB GPU)：**
    - 攻击者想用满 `p=4` 的并行度来跑一次计算，需要 `256MB` 内存
    - 那么他的 96GB 内存最多能同时进行 `96GB / 256MB = 384` 次哈希计算
    - 即使他的 GPU 有 16000 个核心，但由于内存限制，**只有 `384 * 4 = 1536` 个核心在有效工作**
    - 超过 90% 的核心都在因为等待内存而闲置。

综上，通过`内存成本（m）、迭代次数（t）和并行度（p）`，大大增加了attacker的破解成本与难度

## 补充：衍生版本

- **Argon2d**: `d` 代表 data-dependent
    - 内存访问的地址依赖于之前计算出的数据
    - 这使得它**最大程度地抵抗 GPU 破解**，因为 GPU 无法预测内存访问模式来进行优化
    - 但缺点是可能会受到侧信道攻击（Side-channel attack）
- **Argon2i**: `i` 代表 data-independent
    - 内存访问地址不依赖于输入密码，能抵抗侧信道攻击
    - 但代价是 GPU 破解的抗性稍弱于 Argon2d
- **Argon2id (OWASP 推荐)**: 这是一个混合模式
    - 它在第一次迭代时使用 Argon2i 的模式，后续迭代使用 Argon2d 的模式
    - 这样既获得了对侧信道攻击的良好防御，又保持了对 GPU 破解的强大抵抗力
    - `线程间频繁同步通信` 极大地增加了 GPU 这种共享内存架构的内部延迟和性能损耗

# 第三课：哈希加密算法流程

## 通用场景设定

1. 用户输入账号admin 与密码 password123
2. 前端将`{"username": "admin", "password": "password123"}` 这个JSON数据通过HTTPS协议发送到后端Spring Boot服务器
3. 后端接收了请求，首先拿着`admin`去数据库表中进行比对，查询用户记录
4. 后端从数据库中取回了该用户的数据，其中密码字段存储的是一长串经过哈希的字符串。

## 算法流程

哈希字符串示例：`$argon2id$v=19$m=65536,t=3,p=4$R...salt...$d...hash…`

- `$argon2id$`: Argon2id算法的标识符，`v=19`: 算法版本，不是我们的重点
- `m=65536,t=3,p=4`:表示需要65536KiB内存（64GB），3次迭代，4个并行线程计算
- `R...salt...`: 盐 (Salt)
- `d...hash...`: 最终计算出的哈希值

后端验证流程如下：

1. 前端给后端提供了明文密码`password123`，加密算法库接收到这个信息（比如是Argon2库），它解析出了其中的参数`m=65536,t=3,p=4`，以及需要盐
2. 申请大内存并分片：库函数在内存中申请一块大小为 `m=64 MiB` 的内存。这块内存被逻辑上划分为 `p=4`个并行的“泳道(Lane)”
3. 启动并行计算：库函数启动 `p=4`个线程
4. 第一次迭代（填充内存）：
    1. 4个线程同时开始工作，每个线程负责填充自己对应的 泳道
    2. 计算泳道中的每一个数据块时，其值都依赖于之前计算过的块
    3. 关键在于，计算一个块可能需要引用`其他线程（泳道）`计算出的数据块。这强制线程之间需要进行数据同步
5. 后续迭代（混合内存）：
    1. 整个填充和混合过程将重复执行 `t=3` 次
    2. 在第2、3次迭代中， `p=4`个线程继续并行地、根据复杂的规则重写内存块的内容，计算每个块时依旧会依赖其他泳道在前一次迭代中产生的数据
    3. 这进一步加强了数据的混乱和依赖性
6. 生成结果：完成3次迭代后，将最终内存块中的所有数据进行一次最终的哈希计算，产出结果
7. 比较：将新生成的哈希与数据库中存储的哈希部分进行比较
8. 返回结果：如果相同，验证成功。否则失败